from scipy.ndimage.interpolation import zoomimport numpy as npfrom keras import backend as Kfrom vis.backprop_modifiers import guideddef getCAM(X,model,resize_factor=0,layer_maps=-4):    #Create functions ----------    #define layer weights    layer_weights = layer_maps + 2    #create function output feature maps     convout1 = model.layers[layer_maps]    convout1_f = K.function([model.input], [convout1.output])               #Apply to the image -----------    #retrieve weights          W = model.layers[layer_weights].get_weights()    W = np.squeeze(W[0])    #compute feature maps    C1 = convout1_f([X])    C1 = np.squeeze(C1)    #commute linear combiantion    attention_map = np.zeros(C1.shape[:-1])    for i,w in enumerate(W):                                attention_map = attention_map + w*C1[...,i]             #Postproc -------------     #resize     if resize_factor != 0:                   attention_map = zoom(attention_map,resize_factor,order=1)       return attention_mapdef getGradCAM(X,model,resize_factor=0,layer_maps=-4):    #Create functions ----------    #GRAD - backprop    #create function    model = guided(model)    saliency = K.gradients(K.sum(model.outputs[-1]), model.layers[layer_maps].output)    pooled = K.mean(saliency[0],axis=list(range(len(saliency[0].shape)-1)))    grad = K.function([model.layers[0].input], [pooled])        #CAM    #create function output feature maps     convout1 = model.layers[layer_maps]    convout1_f = K.function([model.input], [convout1.output])          #Apply to the image -----------    #compute weights Alpha    Alpha = grad([X])[0]        #compute feature maps     C1 = convout1_f([X])    C1 = np.squeeze(C1)    #commute linear combiantion    attention_map = np.zeros(C1.shape[:-1])    for i,alpha in enumerate(Alpha):                                attention_map = attention_map + alpha*C1[...,i]         #Postproc -------------     #resize     if resize_factor != 0:                   attention_map = zoom(attention_map,resize_factor,order=1)        return attention_mapdef getGradOrGuidedBackprop(X,model,mode='guided'):    #Create functions ----------    if mode=='guided':        model = guided(model)    saliency = K.gradients(K.sum(model.outputs[-1]), model.layers[0].input)    grad = K.function([model.layers[0].input], saliency)        #Apply to the image -----------    attention_map = np.squeeze(grad([X]))      return attention_map  